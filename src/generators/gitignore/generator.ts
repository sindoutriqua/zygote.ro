import type { Generator, GeneratorOutput } from '../types';
import { osRules, languageRules, frameworkRules, commonRules } from './rules';
import type { GitignoreRuleSet } from './types';

export const gitignoreGenerator: Generator = {
    id: 'gitignore',
    name: '.gitignore Generator',
    description: 'Generate a comprehensive .gitignore file based on your technology stack.',
    inputs: [
        {
            name: 'projectType',
            label: 'Project Type',
            type: 'select',
            options: ['library', 'cli', 'web', 'embedded'],
            defaultValue: 'library',
            required: true,
        },
        {
            name: 'languages',
            label: 'Languages',
            type: 'checkbox', // UI needs to support multi-select or checkbox group
            options: Object.values(languageRules).map(r => r.id),
            // We might want to pass formatted options with labels in a real generic UI, 
            // but here we just pass IDs. The UI component will need to map these or we change 'options' structure.
            // For now, let's assume the Custom UI will handle the rich verification.
        },
        {
            name: 'frameworks',
            label: 'Frameworks / Toolchains',
            type: 'checkbox',
            options: Object.values(frameworkRules).map(r => r.id),
        },
        {
            name: 'os',
            label: 'Operating Systems',
            type: 'checkbox',
            options: Object.values(osRules).map(r => r.id),
            defaultValue: ['macos', 'windows', 'linux'],
        },
        {
            name: 'extras',
            label: 'Common Extras',
            type: 'checkbox',
            options: Object.values(commonRules).map(r => r.id),
            defaultValue: ['logs', 'env', 'editors'],
        },
    ],
    generate: (data: Record<string, any>): GeneratorOutput => {
        const {
            projectType,
            languages = [],
            frameworks = [],
            os = [],
            extras = [],
        } = data;

        const addedRules = new Set<string>();
        const lines: string[] = [];

        lines.push(`# .gitignore generated by zygote.ro`);
        lines.push(`# Project Type: ${projectType}`);
        lines.push(`# Timestamp: ${new Date().toISOString()}`);
        lines.push('');

        // Helper to process a list of rule set IDs from a source collection
        const processRuleSets = (selectedIds: string[], source: Record<string, GitignoreRuleSet>, header: string) => {
            const validIds = selectedIds.filter(id => source[id] || Object.values(source).find(r => r.id === id));

            if (validIds.length === 0) return;

            let hasHeader = false;

            validIds.forEach(id => {
                // Find rule by id or matches (source is Record<string, RuleSet>, key might differ from id)
                const ruleSet = Object.values(source).find(r => r.id === id);
                if (!ruleSet) return;

                // Filter content for duplicates
                const uniqueRules = ruleSet.content.filter(rule => {
                    // Check for duplicate
                    if (addedRules.has(rule)) return false;

                    // Special handling for Rust Cargo.lock
                    // If project is CLI/Web/Embedded (Executable), we usually WANT Cargo.lock tracked (so DO NOT ignore it).
                    // If project is Library, we usually want it ignored (so DO ignore it).
                    // DEFAULT in rules/languages.ts is to IGNORE it.
                    // So if type != library, strict skip 'Cargo.lock'?
                    // "The .gitignore file is a Day-0 project artifact."
                    // "It should help users avoid common mistakes."
                    if (rule === 'Cargo.lock') {
                        if (projectType === 'library') {
                            // Library: Ignore Cargo.lock
                            return !addedRules.has(rule);
                        } else {
                            // Binary: Track Cargo.lock (Exclude from gitignore)
                            return false;
                        }
                    }

                    return true;
                });

                if (uniqueRules.length > 0) {
                    if (!hasHeader) {
                        lines.push(`# --- ${header} ---`);
                        hasHeader = true;
                    }
                    lines.push(`# ${ruleSet.name}`);
                    uniqueRules.forEach(rule => {
                        addedRules.add(rule);
                        lines.push(rule);
                    });
                    lines.push('');
                }
            });
        };

        // 1. OS
        processRuleSets(Array.isArray(os) ? os : [os], osRules, 'Operating Systems');

        // 2. Languages
        processRuleSets(Array.isArray(languages) ? languages : [languages], languageRules, 'Languages');

        // 3. Frameworks
        processRuleSets(Array.isArray(frameworks) ? frameworks : [frameworks], frameworkRules, 'Frameworks & Toolchains');

        // 4. Extras
        processRuleSets(Array.isArray(extras) ? extras : [extras], commonRules, 'Common Extras');

        return {
            files: [{
                filename: '.gitignore',
                content: lines.join('\n').trim() + '\n',
                language: 'text',
            }],
        };
    },
};
